待做:
    1、消息的接收好像还没写全;      /** --OVER-- **/
    2、在“登录”之前好像要等一些线程执行完才行;     /** --测试成功-- **/
    3、在聊天时发送图片怎么解决;（应该是要修改表）   /** --应该是over -- **/
    4、创建群聊;                   /** --OVER-- **/
    //5、邀请群聊;
    6、搜索群聊;                   /** --OVER-- **/
    7、加入群聊;                   /** --OVER-- **/              缺陷:加入时群内无提示
    //8、管理员任命(表?);
    //9、管理员权限;
    //10、踢出群聊;
    11、退出群聊;
    12、删除好友;

    13、以上一些操作要有接收方(好友或群内成员)的提醒;
    14、登录后好友的头像显示       /** --OVER --**/
    15、好友的备注功能
    16、好友的信息显示（详细信息）

问题:如何在群用户修改信息后在群界面中实时得到修改?

关于上传问题:
    上传文件:用udp的话，需要牵扯到接收方服务器如何知道发送者的ID.首先不可能使用报头标记的方式，因为发送的是数组，无法转换为字符串;
    提前发送userID告知的话，服务器先接收到一个userID和文件名信息，根据此信息定位文件夹和文件名.然后发送数组，服务器将预选字符串
(服务器至少有一个心跳检测的报头)转化的数组与包信息比对，若均无匹配则说明为文件信息.然后将其写入指定文件中去，而这个路径要用全局变
量来存储，这样会导致所有用户同时只能上传一个文件.

似乎只能对每个群建立一个单独的线程了;
(线程太多会导致程序卡么？)
    over用户登录时，获得群列表，每一项都包含最新消息及发送时间;群列表根据types查询用户的contactlist表，再对每个查询相应群表的最新消息(groups表中),组合成为SimpleGroup对象列表;
    over用户登录时，开启群监听线程
    over用户修改个人信息时群信息也要作修改，但是此时已经打开群聊界面的人是看不到这个修改的.只有重新打开群界面才会看到修改后的信息;
    over用户修改个人信息时，联系人中所有好友对应的联系人列表中该用户的信息也要作出修改，而且需要将此好友对应记录的isUpdate换成1(即true);
    over（前提，有一个根据userID判断用户是否为相应群群主的方法）(群主)修改群信息时,修改群信息表中的内容,并将改群所有成员的contactlist表中该记录的isUpdate值改为1;
    over有人进行群聊时,向该群的chatdata中插入此条信息.
    over获取群聊天消息:用户登录时，每个群都建立一个线程,在此线程中,首先以用户上次退出登录时间为起点，用此时间去查询该群chatdata是否有新的群聊内容.若有，则获取对象(列表)，然后
将时间重置为查询到的消息中的最近时间，用此时间代替退出登录的时间执行下一次的监听查询.

难点：用户修改个人信息(头像等);群主修改群信息(群头像等);用户接收群消息;


    over用户修改个人信息时:不仅要修改userInfo表中的信息，用户的所有好友对应的contactlist表中该用户的记录也要修改，用户加入的所有群对应的group_member表中该用户的记录也要修改.
        over而且这个修改还要反映出来:好友列表中该用户的isUpdate值改为1；至于群则先不予考虑，因为反正每次打开群界面都要重新加载群用户记录(但程序不重启，好友列表是不会重新加载的).

    over群主修改群信息时:(关键还是如何让这个变化反应给每个用户)不仅要修改groups表中该条记录，还要修改群中每位成员所在contactlist表中该记录的数据(contactlist同时记录群和好友,但程序是把它们分开处理的).
        over修改该条记录时还要将isUpdate的值改为1.

    over用户接收群信息时:
        over如何将这个变化反应到群列表中？
        over(用户发送群信息时，向该群的chtadata中插入此条信息.----效率太低了，舍弃)
        over在用户监听群消息的线程中，将查询到的群聊内容中时间最新的那条消息及最新时间单独额外取出来，调用全局变量Map<String,SimpleGroup>的get(groupID)(每
    over个群都有这样一个线程)中SimpleGroup的settheLatestMessage()及settheLatestSendTime()方法更新最新消息.

    over用户登录时开启好友监听线程(已做)和群监听线程.
        over群监听线程:监听contactlist中types为1的记录是否存在isUpdate为1的记录.若存在，取出该记录，重新组成一个SimpleGroup对象列表(含最新消息和最新消息发送时间及其获取步骤).用每个对象去替换全局变量Map<String,SimpleGroup>列表.

    overPS:在用户添加群或创建群时(删除群？)也要在方法中开启监听群聊天信息的线程.
LoginClient.GroupListenerThread中有不必用到的代码


用户注册后应该随之新建个数据库用来存放上传文件的路径，没有这个代码，所以目前也没法上传文件；
上传文件的代码还没写完，比如对数据库的操作（有相同文件时和无相同文件时）；
注册时随机生成的号码并不能包含所有可能的10位数；


关于P2P实现聊天的初步思路：
    关于用户，对于某个用户，需要建立他对每一个（好友）人的聊天记录数据表；
    用户信息一栏需要插入加入IP地址列，在用户每次登陆时，客户端向服务端发送一串数据（后台写的、已确定的任意数据），由此得到客户
端每次登录的IP地址（P2P连接需要服务器知道每个客户端的IP，而且在进行聊天之前就要已经存好）。如果这次登录的IP和上次不同，可以提示
用户帐号可能被盗（登录地点发生了改变），并且必须更新数据库表里用户的IP地址信息。————这就要求客户端在每次用户登录时用DatagramSocket
向服务端发送任何数据（或者通过可能的其它手段直接获得客户端的nat映射IP并提交给服务端——这应该是行不通的）
    /*（删）用户在外网的nat地址是不是会发生动态更改？*/

    在线聊天和离线聊天应该是有区别的；在线即时聊天用p2p，离线应该是用数据库；
    //客户端怎么实现？
    有没有办法能够让客户端在用户双击某人头像打开聊天框时获得双方的帐号（目前想到的必需的操作）？
    。。。。。。。（烧脑中）


    map集合不需要每次上线都检查一遍集合中

    客户端请求servlet，之后再发送数据包到指定IP和端口

        *登录的时候服务端是不是要开个多线程？（如果有多个客户端同时登录）
        *服务端每开一个线程都要开一个端口？（同一个端口应该会被占用）
    发送方的地址没有用到或被发送
    web.xml里的listener是监听，在运行的时候执行background包下的AutoLauncher类（AutoLauncher类是自启动代码)


    怎么移植：例子——登录：
        把LoginAddressServer放到前端的类中

    发送的消息似乎有长度限制


    服务器不能指定空DatagramSocket，客户端可以（？）
        *服务端能否随机指定一个端口？值得一试
    客户端收发数据用同一个端口


    SocektAddress的端口改变，服务器解析出的端口就会变


    用户注册时，需要同时创建用户的联系人（包括好友和群）表。表中栏名为：ID主键不可为空、名称nickName不可为空（用户名/群名）、头像（用户头像/群头像）可为空、联系人类型（好友/群）、联系人状态（上下线）、状态是否有更新;
    用户注册时，还需要同时创建该用户的聊天记录表。表中栏包括:对方userID，聊天性质（1代表对方想自己发送消息，0代表自己向对方发送消息），消息发送时间
    用户登录时，更改该用户好友列表中含有的用户的表，将表中该好友的状态标为1;用户下线时类似;
    /* PS：客户端使用的ds应为final全局变量，因为只有这一个不可更改的ds！*/
    用户登录时，用相同的ds向服务器发送数据包;服务器接受数据包，分析IP和端口，存到存储所有用户的表中address一栏;
    用户登录时，向服务器发送的数据包中还应该包含本机的地址：综上所述，数据包的内容:Login/userID/LocalAddress(LocalIP:LocalPort)
    用户登录后，每隔100s向服务器发送心跳包保证通讯（属于客户端代码），心跳包内容:Heartbeat/userID/LocalAddress(LocalIP:LocalPort)，这个心跳包还用于服务器更新客户端随时可能发生变化的地址
    发送心跳包之前，客户端自行判断本机局域网IP是否发生变化，以尽量减轻服务器的负担

    曾经试图通过两个服务器相互转发与客户端尝试发送数据包来判断客户端NAT类型，不过后来意识到只要能区分是否在局域网通信即可，不需要考虑NAT类型(一律用服务器转发的方式).(因为当两个客户端如果处在同一个NAT下，即在同一个局域网中，那么经过服务器转发的数据是有可能收不到的)


    登录和聊天模块重构：
    考虑到当用户的地址发生变化时应当断开连接并重连(下线并尝试上线).之前的思路整体需要做出改变.
    用户登录时，更改该用户好友列表中含有的用户的表，将表中该好友的状态标为1,isupdate改为1;用户下线时类似(0,1);
    用户登录时，用相同的ds向服务器发送数据包;服务器接受数据包，分析IP和端口，存到存储所有用户的表中address一栏;
    用户登录时，向服务器发送的数据包中还应该包含本机的地址：综上所述，数据包的内容:Login/userID/LocalAddress(LocalIP:LocalPort);

    //
    用户登录时，请求servlet并获得在线联系人列表.(Json)
    用户登录后，每隔100s向服务器发送心跳包保证通讯（属于客户端代码），心跳包内容:Heartbeat:userID，这个心跳包还用于服务器更新客户端随时可能发生变化的地址(虽然延迟有点大).
    服务器接收心跳包后，取出userID，查询用户的外网地址，和数据包的来源进行比较，若相同，则不作处理，否则返回数据包"PublicAddressChanged";
    客户端存有一个全局final环境常量LOCAL_ADDRESS，客户端登陆后将局域网地址赋给次常量开启一个监听线程，每隔3s检查一次自己的局域网地址是否发生变化.若变化，则断线(结束main程序)，重连(自动重启main程序，最好能自动登录);
    客户端若收到数据包"PublicAddressChanged"，同样，断线，重连.
    怎么获得最近消息？消息包括群组消息、聊天消息提醒、好友/群组请求(、踢出群组提醒、删除好友提醒);
        在线时直接p2p传输，所以只需要在上线时查询一下servlet即可.servlet根据userID查询数据库中：
            userInfo表，获得该用户上次下线的时间;
            对应用户的ChatData表，获得此时间之后的最新的消息(按时间排序取最值)且发送者ID不重复的数据，将此记录的所有数据用ChatMessage类封装
            对应用户的被邀请表，获得所有信息，用InviteMessage类封装，转Json.
        ChatMessage类:需要包含一条信息应该具有的全部属性
        InviteMessage类：比较简单
        Json将message转换成数组，发送到客户端.
    刚上线时的步骤就完成了

    聊天重构:
        用户登录成功后，访问ContactServlet，servlet接收userID，调用方法获得ArrayList<Contact>列表，对其中每个对象获得ID,用此ID查询数据库聊天表与anotherID匹配的记录，获取其中时间最新的消息.调用setTheLatestText()将消息添加进Contact对象中.返回ArrayList<Contact>列表    (Login.getContactList()方法需要重写/修改);
        客户端获得此ArrayList后获取其ID,nickName,headIcon,types,status,theLatestText将ID,nickName,headIcon,status,types和theLatestTest显式显示出来.




        !!!在超时判断时，用于超时判断的(两个!)receive()方法也应该实现主方法中被暂停掉的receive()方法的功能.
        外网发送通过获得返回数据确定信息发送成功的方法在一个用户同时向两个用户发送信息时会产生bug.但是问题应该不大.因为一般用户是来不及同时向两个人发送信息的(超时判定为0.5~1s).
        客户端接收消息的线程中对receive()到的信息进行讨论的时候没有创立线程，而是直接if分支解释，这样子如果接收的请求不止一个就可能会丢失数据.(而接收文件的线程则根据相关头信息开辟新的线程)



        删除------------------------------客户端用Map<String userID,Boolean isInLocal>数据类型存储每个用户是否在局域网中

        将接收消息的线程变量receiveMessageThread设置为static全局变量.当在线时，发送数据的一瞬间，先携带接收者ID请求servlet，此servlet查询该用户是否在线(查询数据库).若在线，将全局线程wait掉，开启自线程.向子线程
        中传输ds，子线程中向目标局域网发送包，然后receive，设置最大等待时间(用线程的join()方法).退出线程后恢复全局线程.如果没有收到应答，换用外网转发.

    怎么实施判断对方的上下线动作？客户端每隔一段时间开一个线程向servlet发送请求，获得好友列表中修改过status(通过isupdate的值判断)的联系人userID列表，将他们标记为相应状态(上线或下线).
    之后只保留联系人中状态变为1的键值对.用此键值对请求servlet

    聊天模块：
    怎么实施判断对方的上下线动作? 客户端每隔一段时间(开一个线程)就向servlet发送请求，获得好友列表中修改过status(通过isupdate的值判断)的联系人userID列表，将他们标记为相应状态(上线或下线).
    如何判断是在线聊天还是离线聊天?在用户发送消息的一瞬间（即客户端得到用户发的消息后），客户端请向servlet发送本用户和对方用户的userID，servlet接收数据并查询本用户的联系人表中对方用户的状态是否为1/在线，并将结果告知客户端，客户端根据结果决定通讯方式;
    用户的状态必须放在好友的好友表中，不能放在记录所有用户的表中，因为好友表必须要有状态一栏，以便查看并更新用户状态;
    在线聊天:用户向其它在线用户发送消息时，其所处的客户端在发送前进行预处理，将原字符串开头加上From:发送用户的ID发送方的昵称长度发送方的昵称To:发送到的用户的ID:发送时间:，发送地址为服务器;服务器截留信息，取出发送方、接收方，发送时间和消息内容，存入两方的聊天记录表中，同时（线程）将数据转发到指定地址;
    （如果不用在线聊天udp的话，（对方）用户就需要开启一个线程每隔一段时间从servlet获取最新的消息通知，就不具有实时性了）;
    用户在登录后开启接收线程，用相同的ds，接收服务器发送的数据，若数据以From开头，则截取收到的数据，获得发送方的ID和昵称，当然还有消息内容和发送时间，而后的处置就看客户端自己了;
    如果用户接收到的服务器发送的数据是以Group开头，则用split("|")截取字符串，第一部分为与发送相关的信息（依次为发送者userID 发送者昵称长度 发送者昵称 群ID 群昵称长度 群昵称 发送时间），第二部分往后则是发送的消息内容，将它们重组为字符串，中间不要忘了重新添加上|字符（这里的|字符是作为消息内容的所以要添加回去）
    离线聊天：用户向离线用户发送消息时，客户端请向servlet发送发送方ID，接收方ID以及消息内容;servlet接收数据后将其存入两方的聊天记录表中;
    在线群聊：用户在群中发送消息后，客户端将用户的userID、用户昵称以及群ID、消息内容、发送时间告知servlet，servlet接收到消息后开启线程查询该群表中的所有在线用户，获取它们的address，并将该数据用\分隔，在此条数据前面添加Group（字符串）、发送者的userID、昵称长度、昵称、群ID、群昵称长度、群昵称、发送时间（不用\分隔）|，在此条数据后面用|分隔添加消息内容;
组装完成后servlet向服务器发送这条dp;在这之后servlet将这条聊天记录存到数据库中该群组的表中（这即是离线群聊）;
（因为昵称里可能含有\字符，所以不能用\分隔各数据）
    （循环\+address如果这样字，split("\")的第一个元素是不是为空，需要试验一下）
    另一方面，服务器接收到该数据后判断开头为Group为群发消息，然后开启线程，用split("|")拆包，获得三部分数据：1、与发送相关的信息;2、接收者的address数组;3、消息内容（该部分可能不只一个数组，但绝对是从第三个数组开始的）；
    服务器重组数组第一个元素和第三个向后的元素，各部分间将|添加回去，将重组后的数据依次向第二个元素的各个地址发送dp;

    群组有两种表，一种是作为ContactList的一部分，存储所有群;另一种是自己的表，用于存储聊天记录，分栏有发送者userID，发送者昵称，消息内容，消息发送时间;
    用户的聊天记录表只有和好友的聊天记录;群聊记录在群聊记录表中;

    用户登录时和登陆后，开启一个监听线程，每隔一段时间(间隔尽量短一点)，向servlet发送该用户的帐号，servlet接收请求后查询该用户的好友列表（不查找群），找出上下线状态或昵称有更新的记录，将ID及修改内容返给该用户，并更新该记录为未修改过的。最后servlet向前端返回修改过的用户ID json格式数据（ID+内容的数组。PS：若是昵称修改，则第二个数据以Change开头）;
    群ID为6位数，以防混淆;



    文件发送模块:
    判断是否在局域网内:用户登录时，还要向servlet发送自己的内网IP地址和端口;servlet接收请求并将内网IP地址和端口存入所有用户表中;用户登录后设立一个线程，每隔一段时间就携带自己的内网IP和端口向servlet发送请求;servlet接收请求并将地址与数据库中的进行比较
    用户表中需要新建一个内网地址列(IP+端口);新建一个NATType列(0代表对称型NAT，1代表非对称性NAT)
    NAT检测：用户登录时先向辅助服务器发送数据包(包含用户userID)，同时将同一个数据包发到此项目的服务器上.两服务器接收数据包后解析IP和端口.获得此值后辅助服务器将两个地址(只需比较端口值)作比较，若相同，则不是对称型NAT(可以实现在线发送文件);若不相同，则
是对称型NAT(不能发送在线文件，只能发送离线文件)，服务器将结果存入用户表中相应用户的行中
    当用户与其它用户
    两用户均在线时——





进展:完成了发送邀请、同意邀请，拒绝邀请还没写